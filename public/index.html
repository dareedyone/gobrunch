<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go brunch</title>
    <style>
        svg {
            border: 2px solid burlywood;
            /* background-image: "url('./assets/svgs/index.jpeg')"; */
        }

        button {
            padding: 5px;
            background-color: rgb(58, 58, 194);
            color: white;
        }

        /* .seat {
            fill: rgb(240, 238, 236);
        } */



        .custom-file-upload {
            border: 2px solid #ccc;
            display: inline-block;
            padding: 5px;
            background-color: rgb(58, 162, 194);
            color: white;
            cursor: pointer;
        }

        input[type="file"],
        button {
            display: none;
        }

        #control-btn-panel {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
        }
    </style>
    <script src="./assets/Snap.svg-0.5.1/dist/snap.svg-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body>
    <div id="container">
        <div id="control-btn-panel">
            <button id="add-circle">Add Circle</button>
            <button id="end-creating">End Creating</button>
            <label for="svg-file" class="custom-file-upload">
                Load
            </label>
            <input id="svg-file" type="file">
            <button id="save-svg">Save</button>
            <button id="delete-svg">Delete</button>

        </div>


        <!-- <svg id="svg" width="1200" height="1170" xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www/w3.org/1999/xlink"> -->
        <!-- 1370 viewBox="0 0 1370 1170" -->
        <!-- for future usage we can make image dynamic -->
        <!-- <image id="image-svg" href="./assets/svgs/index.jpeg" x="0" y="0" /> -->
        <!-- </svg> -->

    </div>




    <script>
        const svgInput = document.getElementById("svg-file");
        const container = document.getElementById("container");
        // const ImageSvg = document.getElementById("svg");
        let svg, DOMSvg, highlightedNode, addCircle = false;



        // Dom elements
        const addCircleButton = document.getElementById("add-circle");
        const endCreatingButton = document.getElementById("end-creating");
        const saveSvgButton = document.getElementById("save-svg");
        const deleteSvgButton = document.getElementById("delete-svg");



        // Functions
        const _createSeat = (x, y, radius) => {
            // TODO  consider class if further actions 
            const seat = svg.circle(x, y, radius);
            seat.attr({
                class: "seat",
                fill: "rgb(240, 238, 236)"
                // id: "seat-1",

            })
        };
        // prev es5 func is used cos of this overhead
        function _move(dx, dy, posX, posY, event) {
            console.log("client", event.clientX, event.clientY);
            console.log("d", dx, dy);
            const point = DOMSvg.createSVGPoint();
            point.x = event.clientX;
            point.y = event.clientY;

            const svgPoint = point.matrixTransform(DOMSvg.getScreenCTM().inverse());

            console.log("client", event.clientX, event.clientY);
            console.log("d", dx, dy);
            console.log("svg p", svgPoint.x, svgPoint.y);



            this.attr({
                cx: svgPoint.x,
                cy: svgPoint.y
            });
        }



        const handleSvgSave = async () => {
            try {
                clearExistedHighlight();
                const svgWrapper = document.getElementById("svg-wrapper");
                const rawVg = svgWrapper.innerHTML;
                const fileName = window.prompt("Enter your file name");
                if (!fileName)
                    return alert("No file name inserted");

                const response = await axios.post("/api/save_svg", { fileName, rawVg });
                alert(`${response.data.fileName} saved successfully !`)

            } catch (error) {
                console.log("error", error);
            }

        }

        const handleSvgProcess = async (event) => {
            try {
                clearExistedHighlight();
                const formData = new FormData();
                formData.append("svg", svgInput.files[0]);
                const { data: usableSvgString } = await axios.post('/api/process_svg', formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
                // console.log(usableSvgString);
                const divNode = document.createElement("div");
                divNode.id = "svg-wrapper";
                divNode.innerHTML = usableSvgString;
                container.appendChild(divNode);


                // show control buttons 
                const buttons = document.getElementsByTagName("button");
                // console.log("gt", buttons, Object.values(buttons));
                Object.values(buttons).forEach((button => {
                    // console.log("btnId", button.id);
                    const dependentButtons = button.id === "end-creating" || button.id === "delete-svg";
                    if (!dependentButtons) {
                        button.style.display = "inline-block";
                    }

                }))

                // set up the new  svg view box
                DOMSvg = document.getElementsByTagName("svg")[0];
                svg = Snap("svg");
                DOMSvg.addEventListener("click", handleSvgControls)

                // for test 


                // DOMSvg.addEventListener("mousemove", (event) => {
                //     console.log("------------------------");
                //     console.log("event", event);
                //     const rect = DOMSvg.getBoundingClientRect();
                //     console.log("the rect", rect);
                //     // the problem should lies with clientY and rect Y not being the same
                //     // console.log("offset", event.offsetX, event.offsetY);
                //     // console.log("page", event.pageX, event.pageY);
                //     console.log("client", event.clientX, event.clientY);
                // })



                // console.log("the div", typeof usableSvgString);
                // return usableSvgString
            } catch (error) {
                console.log(error);
            }

        }
        // refactor this later for generic elements
        const doHighlight = (event) => {
            // console.log("doHighlight runs");
            // un-target circle and make generic  
            if (event.target.nodeName === "circle") {
                const currentSeat = event.target;
                highlightedNode = Snap(currentSeat);

                // console.log("the seat", seat);
                highlightedNode.attr({
                    stroke: "rgb(58, 162, 194)",
                    "stroke-width": 3,
                    "stroke-dasharray": 7
                });
                highlightedNode.drag(_move, () => {
                    console.log("move started");
                }, () => {
                    console.log("ended");
                });
                deleteSvgButton.style.display = "inline-block";
            }
        }
        const clearExistedHighlight = () => {
            if (highlightedNode) {
                highlightedNode.attr({
                    stroke: "rgb(58, 162, 194)",
                    "stroke-width": 0,
                    "stroke-dasharray": 0
                });
                highlightedNode.undrag();
                highlightedNode = undefined;
                deleteSvgButton.style.display = "none";
            }

        }
        const handleSvgControls = (event) => {
            if (addCircle) {
                doCircleCreate(event);
                return;
            }
            clearExistedHighlight();
            doHighlight(event)

        }

        const doCircleCreate = (event) => {
            // console.log("do circle runs");
            // console.log("ora", DOMSvg.getScreenCTM(), "another", DOMSvg.getScreenCTM().inverse());
            // console.log("event nodeName", event.target.type, event.target.tagName, event.target.nodeName);
            const point = DOMSvg.createSVGPoint();
            const rectPoint = DOMSvg.createSVGPoint();
            point.x = event.clientX;
            point.y = event.clientY;
            const svgPoint = point.matrixTransform(DOMSvg.getScreenCTM().inverse());
            const rect = DOMSvg.getBoundingClientRect();
            const DOMSvgLeftBorderClient = rect.left;
            const DOMSvgRightBorderClient = rect.right;
            const DOMSvgTopBorderClient = rect.top;
            const DOMSvgBottomBorderClient = rect.bottom;


            const radius = 37;
            const rightLeftBottomLimit = radius + 20 // 20 is the constant given 57 + 8 = 65;

            const leftBoundaryLimit = DOMSvgLeftBorderClient + rightLeftBottomLimit;
            const topBoundaryLimit = DOMSvgTopBorderClient + 50; // 50 is the constant given
            const rightBoundaryLimit = DOMSvgRightBorderClient - rightLeftBottomLimit; // 1292 - 57 = 1235
            const bottomBoundaryLimit = DOMSvgBottomBorderClient - rightLeftBottomLimit;

            // calculating svg coords for borders
            // first
            rectPoint.x = leftBoundaryLimit;
            rectPoint.y = topBoundaryLimit;


            let svgRectPoint = rectPoint.matrixTransform(DOMSvg.getScreenCTM().inverse());
            // console.log("first svg rect", svgRectPoint);
            const x1 = svgRectPoint.x;
            const y1 = svgRectPoint.y;

            // second
            rectPoint.x = rightBoundaryLimit;
            rectPoint.y = bottomBoundaryLimit;
            svgRectPoint = rectPoint.matrixTransform(DOMSvg.getScreenCTM().inverse());
            const x2 = svgRectPoint.x;
            const y2 = svgRectPoint.y;
            // console.log("second svg rect", svgRectPoint);


            // const limitCheck = svgPoint.x >= rectPoint.a && svgPoint.x <= rectPoint.c && svgPoint.y >= rectPoint.b && svgPoint.y <= rectPoint.d;
            const limitCheck = svgPoint.x >= x1 && svgPoint.x <= x2 && svgPoint.y >= y1 && svgPoint.y <= y2;

            // console.log("-------------------------");

            // console.log("svgPoint", svgPoint);

            // console.log("client", event.clientX, event.clientY);

            // calc for unbalanced cursor
            // const rectWidthOneOfHundred = rect.width / 100;
            // const rectHeightOneOfHundred = rect.height / 100;
            // const offsetXPercentage = X / rectWidthOneOfHundred;
            // const offsetYPercentage = Y / rectHeightOneOfHundred;
            // const amountXFromRadius = radius * (offsetXPercentage / 100);
            // const amountYFromRadius = radius * (offsetYPercentage / 100);

            // const x = X + amountXFromRadius;  //x position within the element.
            // const y = Y + amountYFromRadius  //y position within the element.


            if (limitCheck) {
                _createSeat(svgPoint.x, svgPoint.y, radius);
            } else {
                // can do some cool warning error animations
                console.log("out of boundary");
            }




        }



        // listeners
        addCircleButton.addEventListener("click", () => {
            clearExistedHighlight();
            document.body.style.cursor = "crosshair";
            addCircle = true;
            document.getElementById("end-creating").style.display = "inline-block";
        });

        endCreatingButton.addEventListener("click", (event) => {
            document.body.style.cursor = "default";
            addCircle = false;
            event.target.style.display = "none";
        });
        svgInput.addEventListener("change", handleSvgProcess);

        saveSvgButton.addEventListener("click", handleSvgSave)

        deleteSvgButton.addEventListener("click", (event) => {
            if (highlightedNode) {
                highlightedNode.remove();
                deleteSvgButton.style.display = "none";
            }
        })



        //  load - for later server loads
        // Snap.load("https://gobrunchnow.herokuapp.com/store/test1.svg", (fragment) => {
        //     console.log("the frag", fragment);
        //     svg.append(fragment)
        // })






    </script>
</body>

</html>